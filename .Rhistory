y<-filter(eps, c(1.5, -0.5),'recursive')
mod1<-Arima(y, c(2, 0, 0))
summary(mod1)
mod1$coef
Mod(ployroot(c(1, -mod1$coef[0], -mod$coef[1])))
Mod(polyroot(c(1, -mod1$coef[0], -mod$coef[1])))
Mod(polyroot(c(1, -mod1$coef[0], -mod1$coef[1])))
mod2 <-(y, c(1,1,0))
mod2 <- Arima(y, c(1,1,0))
summary(mod2)
#ARIMA
sunspot.month
#ARIMA
y<-sunspot.month
plot(y)
Acf)y
Acf(y)
Acf(y,120)
Acf(y,240)
Pacf(y)
Pacf(y, 240)
mod1<-ARIMA(y,c(6,0,0))
mod1<-Arima(y,c(6,0,0))
mod1
Acf(mod1$residuals)
Acf(mod1$residuals, 240)
Pacf(mod1$residuals)
mod1<-Arima(y,c(36,0,0))
mod2<-Arima(y,c(36,0,0))
mod2
knitr::opts_chunk$set(echo = TRUE)
library(foreign)
bronchit <- read.dta(file.choose())
cont_table <- table(bronchit = bronchit$bronchit,
hilevel = bronchit$hilevel,
agegp = bronchit$agegp)
library(epiR)
library(survival)
install.packages('installr')
require(installr)
updateR()
require(installr)
updateR()
updateR()
installr()
installr()
updateR()
knitr::opts_chunk$set(echo = TRUE)
require(survival)
library(epiR)
install.packages("survival")
install.packages("survival")
#tab2 <- table(bronchit$hilevel,bronchit$bronchit,bronchit$agegp)
strat<-epi.2by2(dat=cont_table , method="case.control")
cont_table <- table(bronchit = bronchit$bronchit,
hilevel = bronchit$hilevel,
agegp = bronchit$agegp)
require(survival)
library(epiR)
#tab2 <- table(bronchit$hilevel,bronchit$bronchit,bronchit$agegp)
strat<-epi.2by2(dat=cont_table , method="case.control")
strat$massoc.detail$OR.strata.wald
#tab2 <- table(bronchit$hilevel,bronchit$bronchit,bronchit$agegp)
strat<-epi.2by2(dat=cont_table , method="case.control")
strat$massoc.detail$OR.homog.brday
strat$massoc.detail$OR.strata.wald
tab2 <- table(bronchit$hilevel[bronchit$agegp>=1],bronchit$bronchit[bronchit$agegp>=1],bronchit$agegp[bronchit$agegp>=1])
strat<-epi.2by2(dat=tab2, method="case.control")
strat
strat$massoc.detail$OR.homog.brday
tab2
strat<-epi.2by2(dat=tab2, method="case.control")
data.frame(tab2)
strat<-epi.2by2(dat=tab2, method="case.control")
tab2 <- table(bronchit$hilevel[bronchit$agegp>=1],bronchit$bronchit[bronchit$agegp>=1],bronchit$agegp[bronchit$agegp>=1])
strat<-epi.2by2(dat=tab2, method="case.control")
tab2 <- table(bronchit$hilevel[bronchit$agegp>=1],bronchit$bronchit[bronchit$agegp>=1],bronchit$agegp[bronchit$agegp>=1])
strat<-epi.2by2(dat=tab2, method="case.control")
knitr::opts_chunk$set(echo = TRUE)
bronchit <- read.dta(file.choose())
library(foreign)
bronchit <- read.dta(file.choose())
cont_table <- table(bronchit = bronchit$bronchit,
hilevel = bronchit$hilevel,
agegp = bronchit$agegp)
library(epiR)
#tab2 <- table(bronchit$hilevel,bronchit$bronchit,bronchit$agegp)
strat<-epi.2by2(dat=cont_table , method="case.control")
strat$massoc.detail$OR.strata.wald
epi.2by2(dat=cont_table , method="case.control")
load("~/Downloads/car_environmentLast.RData")
knitr::opts_chunk$set(echo = TRUE)
step <- stepAIC(car_model_box, direction="both")
#guardiamo i valori dell'AIC per vedere qual Ã¨ il miglior modello
library(MASS)
step <- stepAIC(car_model_box, direction="both")
ls(step)
step
step$anova
step <- stepAIC(car_model_box, direction="both")
View(dataCar)
names(dataCar)
names(dataCar)
dataCar <- dataCar[,-c(2,5,7,13)]
model_box_selection <- car_model_box<-lm((price^teta)/teta~.,dataCar)
names(dataCar)
dataCar <- dataCar[,-c(2,5,7,13)]
model_box_selection <- lm((price^teta)/teta~.,dataCar)
summary(model_box_selection)
plot(model_box_selection)
plot(car_model)
plot(car_model_box)
plot(model_box_selection)
summary(model_box_selection)
plot(car_model)
plot(car_model_box)
plot(model_box_selection)
leverageP<-hatvalues(model_box_selection)
summary(leverageP)
leverageP<-hatvalues(model_box_selection)
summary(leverageP)
#soglia
p<-length(model_box_selection$coefficients)+1
n<-length(model_box_selection$residuals)
leverage_treshold<-2*p/n
plot(leverageP,
main="Punti di leva piano Processo chimico",
ylab="Punti di leva hii",
xlab="indice unit?",
col ="blue")
abline(h=leverage_treshold,
col="red")
require(faraway)
halfnorm(leverageP,
ylab="coeff. di leva normalizzati")
install.packages('faraway')
plot(leverageP,
main="Punti di leva piano Processo chimico",
ylab="Punti di leva hii",
xlab="indice unit?",
col ="blue")
abline(h=leverage_treshold,
col="red")
require(faraway)
halfnorm(leverageP,
ylab="coeff. di leva normalizzati")
cooksd <- cooks.distance(Robust_ModSel)
cooksd <- cooks.distance(model_box_selection)
load("~/Downloads/car_environmentLast.RData")
names(dataCar)
dataCar <- dataCar[,-c(2,5,7,13)]
model_box_selection <- lm((price^teta)/teta~.,dataCar)
summary(model_box_selection)
plot(car_model)
plot(car_model_box)
plot(model_box_selection)
plot(leverageP,
main="Punti di leva piano Processo chimico",
ylab="Punti di leva hii",
xlab="indice unit?",
col ="blue")
leverageP<-hatvalues(model_box_selection)
summary(leverageP)
#soglia
p<-length(model_box_selection$coefficients)+1
n<-length(model_box_selection$residuals)
leverage_treshold<-2*p/n
plot(leverageP,
main="Punti di leva piano Processo chimico",
ylab="Punti di leva hii",
xlab="indice unit?",
col ="blue")
abline(h=leverage_treshold,
col="red")
require(faraway)
halfnorm(leverageP,
ylab="coeff. di leva normalizzati")
cooksd <- cooks.distance(model_box_selection)
cook_treshold <- 4/(length(model_box_selection$residuals)-length(model_box_selection$coefficients)-1)
plot(model_box_selection, which=4, cook.levels=cook_treshold)
abline(h=cook_treshold, col="red")
halfnorm(cooksd)
model_box_selection$residuals[44]
mean(dataCar$horsepower)
dataCar[44,]
model_box_selection$residuals[129]
cook_treshold <- 4/(length(model_box_selection$residuals)-length(model_box_selection$coefficients)-1)
plot(model_box_selection, which=4, cook.levels=cook_treshold)
abline(h=cook_treshold, col="red")
halfnorm(cooksd)
model_box_selection$residuals[129]
mean(dataCar$horsepower)
dataCar[129,]
cook_treshold <- 4/(length(model_box_selection$residuals)-length(model_box_selection$coefficients)-1)
plot(model_box_selection, which=4, cook.levels=cook_treshold)
abline(h=cook_treshold, col="red")
halfnorm(cooksd)
model_box_selection$residuals[129]
mean(dataCar$horsepower)
dataCar[129,]
desc(dataCar)
cook_treshold <- 4/(length(model_box_selection$residuals)-length(model_box_selection$coefficients)-1)
plot(model_box_selection, which=4, cook.levels=cook_treshold)
abline(h=cook_treshold, col="red")
halfnorm(cooksd)
model_box_selection$residuals[129]
mean(dataCar$horsepower)
dataCar[129,]
str(dataCar)
cook_treshold <- 4/(length(model_box_selection$residuals)-length(model_box_selection$coefficients)-1)
plot(model_box_selection, which=4, cook.levels=cook_treshold)
abline(h=cook_treshold, col="red")
halfnorm(cooksd)
model_box_selection$residuals[129]
mean(dataCar$horsepower)
dataCar[129,]
str(dataCar)
summary(dataCar)
cook_treshold <- 4/(length(model_box_selection$residuals)-length(model_box_selection$coefficients)-1)
plot(model_box_selection, which=4, cook.levels=cook_treshold)
abline(h=cook_treshold, col="red")
halfnorm(cooksd)
model_box_selection$residuals[129]
mean(dataCar$horsepower)
dataCar[129,]
summary(dataCar)
cook_treshold <- 4/(length(model_box_selection$residuals)-length(model_box_selection$coefficients)-1)
plot(model_box_selection, which=4, cook.levels=cook_treshold)
abline(h=cook_treshold, col="red")
halfnorm(cooksd)
model_box_selection$residuals[3]
mean(dataCar$horsepower)
dataCar[3,]
summary(dataCar)
library(car)
influencePlot(Robust_ModSel,  main="Influence Plot" )
install.packages('car')
install.packages("car")
library(car)
influencePlot(Robust_ModSel,  main="Influence Plot" )
library(car)
influencePlot(model_box_selection,  main="Influence Plot" )
Influenti <- as.numeric(names(cooksd)[(cooksd < cook_treshold)])
dataCarNoInflu=data.frame(dataCar[cooksd <  cook_treshold, ])
model_No_Influ <- lm(((price^teta)/teta)~., data=dataCarNoInflu)
summary(model_No_Influ)$adj.r.squared
par(mfrow=c(2,2))
plot(model_No_Influ)
par(mfrow=c(1,1))
#Togliamo ora i punti Maggiormente influenti ed i punti di leva
dataCar=data.frame(dataCar[(cooksd <  cook_treshold) || (leverageP < leverage_treshold), ])
#Togliamo ora i punti Maggiormente influenti ed i punti di leva
dataCar=data.frame(dataCar[(cooksd <  cook_treshold) || (leverageP < leverage_treshold), ])
#Ristimiamo ora il modello privo di valori Influenti e di Leverage Point
model_No_Influ <- lm(((price^teta)/teta)~., data=dataCar)
summary(RobustFree)
#Togliamo ora i punti Maggiormente influenti ed i punti di leva
dataCar=data.frame(dataCar[(cooksd <  cook_treshold) || (leverageP < leverage_treshold), ])
#Ristimiamo ora il modello privo di valori Influenti e di Leverage Point
model_No_Influ <- lm(((price^teta)/teta)~., data=dataCar)
summary(model_No_Influ)
par(mfrow=c(2,2))
plot(model_No_Influ)
par(mfrow=c(1,1))
plot(model_No_Influ)
plot(model_box_selection)
#Togliamo ora i punti Maggiormente influenti ed i punti di leva
dataCar=data.frame(dataCar[(cooksd <  cook_treshold) || (leverageP < leverage_treshold), ])
#Ristimiamo ora il modello privo di valori Influenti e di Leverage Point
model_No_Influ <- lm(((price^teta)/teta)~., data=dataCar)
summary(model_No_Influ)
par(mfrow=c(2,2))
plot(model_box_selection)
plot(model_No_Influ)
par(mfrow=c(1,1))
plot(model_box_selection)
plot(model_No_Influ)
#Togliamo ora i punti Maggiormente influenti ed i punti di leva
dataCarNoInfluNoLev=data.frame(dataCar[(cooksd <  cook_treshold) || (leverageP < leverage_treshold), ])
#Ristimiamo ora il modello privo di valori Influenti e di Leverage Point
model_No_Influ <- lm(((price^teta)/teta)~., data=dataCarNoInfluNoLev)
summary(model_No_Influ)
par(mfrow=c(2,2))
plot(model_box_selection)
plot(model_No_Influ)
par(mfrow=c(1,1))
load("~/Downloads/car_environmentLast.RData")
names(dataCar)
dataCar <- dataCar[,-c(2,5,7,13)]
model_box_selection <- lm((price^teta)/teta~.,dataCar)
leverageP<-hatvalues(model_box_selection)
summary(leverageP)
#soglia
p<-length(model_box_selection$coefficients)+1
n<-length(model_box_selection$residuals)
leverage_treshold<-2*p/n
plot(leverageP,
main="Punti di leva piano Processo chimico",
ylab="Punti di leva hii",
xlab="indice unit?",
col ="blue")
abline(h=leverage_treshold,
col="red")
require(faraway)
halfnorm(leverageP,
ylab="coeff. di leva normalizzati")
cooksd <- cooks.distance(model_box_selection)
cook_treshold <- 4/(length(model_box_selection$residuals)-length(model_box_selection$coefficients)-1)
plot(model_box_selection, which=4, cook.levels=cook_treshold)
abline(h=cook_treshold, col="red")
halfnorm(cooksd)
model_box_selection$residuals[3]
mean(dataCar$horsepower)
dataCar[3,]
summary(dataCar)
library(car)
influencePlot(model_box_selection,  main="Influence Plot" )
Influenti <- as.numeric(names(cooksd)[(cooksd < cook_treshold)])
dataCarNoInflu=data.frame(dataCar[cooksd <  cook_treshold, ])
model_No_Influ <- lm(((price^teta)/teta)~., data=dataCarNoInflu)
summary(model_No_Influ)$adj.r.squared
par(mfrow=c(2,2))
plot(model_No_Influ)
par(mfrow=c(1,1))
#Togliamo ora i punti Maggiormente influenti ed i punti di leva
dataCarNoInfluNoLev=data.frame(dataCar[(cooksd <  cook_treshold) || (leverageP < leverage_treshold), ])
#Ristimiamo ora il modello privo di valori Influenti e di Leverage Point
model_No_Influ <- lm(((price^teta)/teta)~., data=dataCarNoInfluNoLev)
summary(model_No_Influ)
par(mfrow=c(2,2))
plot(model_box_selection)
plot(model_No_Influ)
par(mfrow=c(1,1))
#Togliamo ora i punti Maggiormente influenti ed i punti di leva
dataCarNoInfluNoLev=data.frame(dataCarNoInflu[leverageP < leverage_treshold, ])
#Ristimiamo ora il modello privo di valori Influenti e di Leverage Point
model_No_Influ <- lm(((price^teta)/teta)~., data=dataCarNoInfluNoLev)
summary(model_No_Influ)
plot(model_box_selection)
plot(model_box_selection)
plot(model_No_Influ)
library(gvlma)
install.packages('gvlma')
library(gvlma)
gvlma(model_No_Influ)
summary(model_No_Influ)
summary(car_model)
summary(car_model_box)
summary(model_box_selection)
summary(model_No_Influ)
drop1(model_No_Influ, test="F")
names(dataCarNoInfluNoLev)
drop1(model_No_Influ, test="F")
drop1(model_No_Influ, test="F")
names(dataCarNoInfluNoLev)
#dataCarNoInfluNoLev<-dataCarNoInfluNoLev[,-c()]
drop1(model_No_Influ, test="F")
names(dataCarNoInfluNoLev)
dataCarNoInfluNoLev<-dataCarNoInfluNoLev[,-c(6,7,11)]
RobustMod<-lm(((price^teta)/teta)~., data=dataCarNoInfluNoLev)
summary(RobustMod)
drop1(model_No_Influ, test="F")
names(dataCarNoInfluNoLev)
#dataCarNoInfluNoLev<-dataCarNoInfluNoLev[,-c(6,7,11)]
RobustMod<-lm(((price^teta)/teta)~., data=dataCarNoInfluNoLev)
summary(RobustMod)
plot(RobustMod)
summary(RobustMod)
plot(car_model)
plot(RobustMod)
save.image("~/Downloads/final_car_environment.RData")
library(keras)
library(tidyverse)
install.packages('tidyverse')
install.packages("tidyverse")
library(tidyverse)
library(keras)
library(tidyverse)
library(keras)
library(tidyverse)
setwd("/Users/giannellig/Public-Healt")
setwd("/Users/giannellig/Documents/GitHub/Public-Healt-Analysis")
load("~/Documents/GitHub/Public-Healt-Analysis/env.RData")
knitr::opts_chunk$set(echo = TRUE)
anova(model_adj, model_int, test = "LRT")
load("~/Documents/GitHub/Public-Healt-Analysis/env.RData")
anova(model_adj, model_int, test = "LRT")
set.seed(500)
Sys.setenv(TZ='GMT') # imposto la time zone
packages <- c("dplyr",'epiR','epitools','ggplot2','caret') # librerie
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(packages[!installed_packages])
}
# Packages loading
invisible(lapply(packages, library, character.only = TRUE))
anova(model_adj, model_int, test = "LRT")
model_adj<-glm(dead~ factor(sex) + factor(education),family=binomial,data=df_colon)
exp(cbind("OR" = coef(model_adj), confint.default(model_adj, level = 0.95)))
model_int<-glm(dead~ factor(sex)*factor(education),family=binomial,data=df_colon)
exp(cbind("OR" = coef(model_int), confint.default(model_int, level = 0.95)))
anova(model_adj, model_int, test = "LRT")
library(epitools)
df_seno$work_bin <- ifelse(df_seno$work == "yes", 1, 0)
# tabella di contingenza
tab <- table(df_seno$entro_60_giorni, df_seno$education_bin, df_seno$work_bin)
tab
epi.2by2(tab, method="cohort.count")
pairwise <- pairwise.prop.test(observed, p.adjust.method = "bonferroni")
pairwise
ind_tumore_seno
strat
setwd("/Users/giannellig/Documents/GitHub/Tetouan-Power-Consumption-Forecasting")
load("~/Documents/GitHub/Tetouan-Power-Consumption-Forecasting/env.RData")
results
dic_ucm_pred
ucm_mod2 <- function(train) {
arm144 <- 10
arm1008 <- 1
# Definizione del modello
mod <- SSModel(V1~SSMtrend(2, list(NA, NA))+
SSMseasonal(144, NA, "trigonometric", harmonics = 1:arm144)+
SSMseasonal(1008, NA, "trigonometric", harmonics = 1:arm1008),
H=NA,
data=train)
# Assegna i valori iniziali ai parametri, parte da 0.
mod$P1inf[] <- 0 # no componenti diffuse
mod$a1[1] <- mean(train[1:144]) # expected value of the initial state vector Î±[1]
vy <- var(train[1:144]) # varianza serie storica (utilizzata sotto per dare un ordine di grandezza)
diag(mod$P1) <- vy*10 # specifichiamo che abbiamo molta incertezza sui valori che abbiamo specificato
#Inizializzazione delle varianze sulla base di vy
pars <- log(c(
logVarEta = vy/10000,
logVarZeta = vy/100000,
logVarOm144 = vy/1000,
logVarOm1008 = vy/100000,
logVarEps = vy/1000
))
# funzione di update
updt <- function(pars, model){
model$Q[1,1,1] <- exp(pars[1]) # level
model$Q[2,2,1] <- exp(pars[2]) # slope
diag(model$Q[3:(2+arm144*2), 3:(2+arm144*2), 1]) <- exp(pars[3]) # seasonality 144
diag(model$Q[(3+arm144*2):(2+arm144*2+arm1008*2), (3+arm144*2):(2+arm144*2+arm1008*2), 1]) <- exp(pars[4]) # seasonality 1008
model$H[1,1,1] <- exp(pars[5])
model
}
# Train - Si allena sui valori passati (quindi quei valori di train non nulli)
fit <- fitSSM(mod, pars, updt)
print(fit$optim.out)
# Filtro di kalman - Effetua le predizioni - kfs1$muhat contiene una serie storica predetta (anche i dati di train vengono predetti)
kfs <- KFS(fit$model,
smoothing = c("state", "signal", "disturbance"))
# conversione muhat in serie storica
muhat <- xts(as.matrix(kfs$muhat),
index(train))
muhat <- as.xts(muhat)
return(muhat)
}
View(ucm_mod2)
diag(model$Q[3:(2+arm144*2), 3:(2+arm144*2), 1])
print(fit$optim.out)
ucm_mod2 <- function(train) {
arm144 <- 10
arm1008 <- 1
# Definizione del modello
mod <- SSModel(V1~SSMtrend(2, list(NA, NA))+
SSMseasonal(144, NA, "trigonometric", harmonics = 1:arm144)+
SSMseasonal(1008, NA, "trigonometric", harmonics = 1:arm1008),
H=NA,
data=train)
# Assegna i valori iniziali ai parametri, parte da 0.
mod$P1inf[] <- 0 # no componenti diffuse
mod$a1[1] <- mean(train[1:144]) # expected value of the initial state vector Î±[1]
vy <- var(train[1:144]) # varianza serie storica (utilizzata sotto per dare un ordine di grandezza)
diag(mod$P1) <- vy*10 # specifichiamo che abbiamo molta incertezza sui valori che abbiamo specificato
#Inizializzazione delle varianze sulla base di vy
pars <- log(c(
logVarEta = vy/10000,
logVarZeta = vy/100000,
logVarOm144 = vy/1000,
logVarOm1008 = vy/100000,
logVarEps = vy/1000
))
# funzione di update
updt <- function(pars, model){
model$Q[1,1,1] <- exp(pars[1]) # level
model$Q[2,2,1] <- exp(pars[2]) # slope
diag(model$Q[3:(2+arm144*2), 3:(2+arm144*2), 1]) <- exp(pars[3]) # seasonality 144
diag(model$Q[(3+arm144*2):(2+arm144*2+arm1008*2), (3+arm144*2):(2+arm144*2+arm1008*2), 1]) <- exp(pars[4]) # seasonality 1008
model$H[1,1,1] <- exp(pars[5])
model
}
# Train - Si allena sui valori passati (quindi quei valori di train non nulli)
fit <- fitSSM(mod, pars, updt)
print(fit$optim.out)
# Filtro di kalman - Effetua le predizioni - kfs1$muhat contiene una serie storica predetta (anche i dati di train vengono predetti)
kfs <- KFS(fit$model,
smoothing = c("state", "signal", "disturbance"))
# conversione muhat in serie storica
muhat <- xts(as.matrix(kfs$muhat),
index(train))
muhat <- as.xts(muhat)
return(muhat)
}
?KFS
?KFS
plot_pred(ucm_pred2)
ucm_stats2 <- stats(data_xts[val_index:(val_index+144*npred-1)], ucm_pred2[(nrow(ucm_pred2)-144*npred+1):nrow(ucm_pred2)])
stats_results[nrow(stats_results) + 1,] <- c("ucm_mod2", ucm_stats2)
df_plot_pred <- merge.xts(ground_truth = data_xts[(val_index-144*4):nrow(data_xts),], pred = ucm_pred2[val_index:nrow(data_xts),])
?SSModel
